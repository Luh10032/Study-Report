20220314~20220320

### unit 2 应用层
- 网路核心没有应用层功能

#### 2.1 应用层协议原里
- 可能的应用架构
>1. 客户-服务器模式 (C/S client)
>2. 对等模式 (P2P: Peer to Peer)
>3. 混合体：客户-服务器和对等体系结构
###### 客户-服务器体系
> - 服务器：
> 一直运行
> 固定的IP地址和端口号
> 扩展性：服务器场  数据中心进行扩展，扩展性差
- 客户端
> 主动与服务器通信
> 与互联网有间歇性的连接
> 可能是动态IP地址
> 不与其他客户端通信
###### 对等体P2P体系结构
- 几乎没有一直运行的服务器
- 任意端系统之间可以进行通信
- 每个节点既是客户端又是服务器(拥有紫扩展性)
- 参与的主机间歇性连接且可以改变IP地址(难以管理)
###### C/S和P2P体系混合体
- Napster下载器
> 文件搜索：集中
> 文件传输：P2P
###### C/S和P2P体系混合体
- 进程：在主机上运行的应用程序。
- 进程通信：在同一个主机内，使用进程间通信机制通信(操作系统定义)
- 不同主机，通过交换报文(Message)来通信
> 从类型来看，网络结构包括网络边缘和网络核心
> - 网络边缘：主机，应用程序
> - 网络核心：互联的路由器，网络的网络
> - 接入网：物理媒体：有线或者无线通信链路
###### 分布式进程通信需要解决的问题
1. 进程标示和寻址问题(服务用户)
2. 传输层-应用层 传输层是如何提供服务的 (服务)
>- 位置 层间界面的SAP(Service Accessing Point 服务访问点 上层访问下层所提供服务的点)(TCP/IP:socket)
>- 形式 应用程序接口API(Application Programming Interface) (TCP/IP:socket API)
3. 如何使用传输层提供的服务，实现应用进程之间的报文交换，实现应用(用户使用服务)
>- 定义应用层协议：报文格式，解释，时序等。编制程序
###### 问题1：对进程进行编址（addressing）
- 进程为了接收报文必须有一个标识 即SAP。
>- 主机：唯一的32位IP地址
>- 采用的传输层协议：TCP OR UDP
>- 端口号
- 一个进程：用IP+端口号port 标示端节点
- 本质上，一个主机进程之间的通信由2个端节点构成
###### 问题2:传输层提供的服务-需要穿过层间的信息
- 层间接口必须携带的信息：
>- 要传输的报文（对于本层来说： SDU service data unit）
>- 谁传的：自己的应用进程的标示：IP+端口
>- 传给谁：对方的应用进程的标示：IP+端口
传输层实体（TCP或者UDP实体）：根据这些信息进行TCP报文段（UDP数据报）的封装
>- 源端口号，目标端口号，数据等
>- 将IP地址往下交IP实体，用于封装IP数据报源IP，目标IP
###### 问题2:传输层提供的服务-层间信息的代表
- TCP socket：
>- TCP服务 两个进程之间的通信需要之前要建立连接，两个进程通信会持续一段时间，通信关系稳定
- 对于使用面向连接服务TCP的应用而言，套接字是4元组的一个具有本地意义的标示
>- 4元组：源IP ，源port ，目标IP，目标port
>- 唯一的指定了一个会话（2个进程之间的会话关系）
>- 应用使用这个标示，与远程的应用进程通信
>- 不必在每一个报文的发送都要指定这4元组
>- 简单，便于管理
- UDP socket：
>- UDP服务，两个进程之间的通信需要之前无需建立连接，每个报文都是独立传输的，前后报文可能给不同的分布式应用进程
>- 穿过层间接口的信息大小最小
>- 传输报文时，必须提供对方的IP，port。接受报文时，传输层需上传对方的IP，port
- 对于使用无连接服务（UDP）的应用而言，套接字是2元组的一个具有本地意义的标示
>- 2元组：IP,port （源端指定）
>- UDP套接字指定了应用所在的一个段节点（end port）
>- 在发送数据报时，采用创建好的本地套接字（标示ID），就不必在发送每个报文中知名自己所采用用的ip和port
>- 但是在发送报文时，必须要指定对方的ip和udp port
- 套接字（socket）
>- 进程向套接字发送报文或从套接字接收报文
>- 套接字 <->门户
>>- 发送进程将报文推出门户，发送进程依赖于传输层设施在另外一侧的门，将报文交付给接受进程
>>- 接受进程从另外一段的门户收到报文(依赖于传输层设施)
###### 问题3:如何使用传输层提供的服务实现应用
- 定义应用层协议：报文格式，解释，时序等。编制程序，通过API调用网络基础射式提供通信服务传输报文，解析报文，实现应用时序
- 
###### 应用层协议
- 定义了 运行在不同端系统用上的应用进程如何互相交换报文。
>- 交换的报文类型：请求和应答报文
>- 各种报文类型的语法：报文中的各个字段及其描述
>- 字段的语义：即字段取值的含义
>- 进程何时，如何发送报文对报文进行响应的规则
- 引用协议仅仅是应用的一个组成部分
 
- 数据丢失率
- 延迟
- 吞吐
- 安全性
>- 机密性
>- 完整性
>- 可认证性
###### Internet传输层提供的服务
- TCP服务
>- 可靠的传输服务
>- 流量控制：发送方不会淹没接收方
>- 拥塞控制：当网络出现拥塞时，能抑制发送方
>- 不能提供的服务：时间保证，最小吞吐保证和安全
>- 面向连接：要求客户在客户端进程和服务进程之间建立连接
###### UDP存在的必要性
- 能够 区别不同的进程 ，而IP服务不能
>- 在IP提供的主机到主机端到端功能的基础上，区分了主机的应用进程
- 无需建立连接，省去了建立连接时间，适合事务性的应用
- 不做可靠性的工作， 
- 无拥塞控制和流量控制， 应用能按照设定的速度发送数据
###### 安全TCP
- TCP和UDP都没有加密 ，明文通过互联网传输，甚至密码
- SSL 在TCP上面实现，提供加密的TCP连接
>- 私密性
>- 数据完整性
>- 端到端的鉴别
- SSL在应用层 应用采用SSL库，SSL库使用TCP通信
- SSL socket API ：应用通API将明文交给socket ，SSL将加密在互联网上传输


#### WEB和HTTP
- web页：由一些对象组成
- web页含有基本的html文件，该基本html文件又包含若干对象的引用
- 通过URL对每个对象进行引用
###### HTTP概况
- HTTP：超文本传输协议
- 是web的应用层协议
- 客户/服务器模式
>- 客户：请求，接收和显示web对象的浏览器
>- 服务器：对请求进行相应，发送对象的web服务器
- 使用TCP：
>1. 客户发起一个与服务器TCP连接（建立套接字）端口号为80
>2. 服务器接受客户的TCP连接
>3. 在浏览器（HTTP客户端）与Web服务器(http服务器server)交换HTTP报文（应用层协议报文）
>4. TCP连接关闭
- HTTP是无状态的：服务器并不维护关于客户的任何信息
- 非持久HTTP:
>1. 最多只有一个对象在TCP连接上发送
>2. 下载多个对象需要多个TCP连接
>3. HTTP/1.0使用非持久连接
- 持久HTTP
>1. 多个对象可以在一个TCP上传输
>2. HTTP/1.1默认使用持久连接
###### 响应时间模型
- 往返时间RTT(round-trip time):一个分组从客户端到服务器，再回客户端的时间（忽略传输时间）
- 响应时间：2RTT+传输时间（一个RTT发起TCP连接，一个RTT发HTTP请求）
###### 持久HTTP
- 非持久HTTP的缺点：
>1. 每个对象那个要2个RTT
>2. 操作系统必须为每个TCP连接分配资源，但浏览器通常打开并行TCP连接，以获取引用对象
- 持久HTTP:
>1. 服务器再发送响应后，仍保持TCP连接
>2. 再相同客户端和服务器之间的后续请求和响应报文通过相同的连接进行传送
>3. 客户端在遇到一个引用对象时候，就可以尽快发送该对象的请求
- 非流水方式的持久HTTP:客户端只能在收到前一个响应后，才能发送一个新的请求。每个引用对象花费一个RTT
- 流水方式的持久HTTP：HTTP/1.1的默认模式。客户端遇到一个引用对象就立即产生一个请求。所有引用对象总计只花费一个RTT是可能的
###### HTTP请求报文
- 两种类型的HTTP报文： 请求报文  ，响应报文
- HTTP请求：ASCII。包括请求行，首部行。
###### 方法类型
- HTTP/1.0:GET,POST,HEAD(要求服务器在响应报文中不包含请求对象->故障跟踪)
- HTTP/1.1:GET,POST,HEAD,PUT(将实体主体中的文件上截到URL字段规定的路径)
###### HTTP响应报文
- 状态行(协议版本，状态码和相应状态信息)，首部行，数据行
###### HTTP响应状态码
- 位于服务器->客户端响应报文中单首行
- 200 OK 请求成功，
- 301 Moved Permanently 请求的对象已经被永久转移了：新的URL在响应报文的location中指定
- 400 bad request 一个通用的差错代码，标示请求不能被服务器解读
- 404 not found 请求的文档在服务上没有找到
- 505 http version not supported
###### 服务-服务器状态：cookies
- 4个组成部分:
>1. 在http响应博文中有一个cookie的首部行
>2. 在HTTP请求报文中含有一个cookie的首部行
>3. 在用户端系统中保留有一个cookie文件，由用户的浏览器管理
>4. web站点有后端数据库
- cookie能带来什么：用户验证，用户状态
###### Web缓存（代理服务器）
- 目的：不访问原始服务器，就满足客户请求
>- 用户设置浏览器，通过缓存访问web
>- 浏览器将所有的HTTP请求发给缓存。如果对象在缓存中，则缓存直接发给对象。如果不在，缓存请求原始服务器，再将对象给客户端
- 缓存即是客户端又是服务器
- 缓存的好处：
>1. 降低客户端的请求响应时间
>2. 可以大大减少组织内部网络与Internet接入链路上的流量
>1. 互联网大量采用了缓存，可以使较弱的ICP野能有效提供内容
- 条件get方法：如果缓存器中的对象拷贝是最新的，就不要发送对象


#### 2.4 Email
- 3个主要组成部分
1. 用户代理
2. 邮件服务器
3. 简单邮件传输协议：SMTP（simple mail transfer protocol）
- 用户代理：
>- 又名“邮件阅读器”
>- 撰写，编辑，和阅读邮件
>- 输出和输入邮件保存在服务器上
- Email邮件服务器
>- 邮箱中管理和维护发送给用户的邮件
>- 输出报文队列保持待发送邮件报文
>- 邮件服务器之间的SMTP协议：发送email报文。
###### SMTP
- 使用TCP在客户端和服务器之间传送报文，端口号为25
- 直接传输：从发送方服务器到接收方服务器
- 传输三阶段：握手， 传输报文， 关闭
- 命令/响应交互
>- 命令：ASCII文本
>- 响应：状态码和状态信息
- 报文必须为7位ASCII码
- 使用持久连接
- 和HTTP比较：
>- HTTP: 是拉协议（pull protocol）
>- SMTP: 推协议（push协议）
>- 二者都是ASCII星驰是命令/响应交互/状态码
>- HTTP:每个对象封装在各自的响应报文中
>- SMTP：多个对象包含在一个报文中
###### 邮件访问协议
- SMTP：传送到接收方的邮件服务器
- 邮件访问协议：从服务器访问邮件
>- POP（post office protocol）邮局访问协议：用户身份确认（代理<-->服务器）并下载
>- IMAP:(internet mail access protocol)internet邮件访问协议：更多特性；在服务器上处理存储的报文


#### 2.5 DNS (Domain DName)
- DNS负责将字符串名称转化为二进制网络地址
- DNS思路：
>1. 分层的，基于域的命名机制
>2. 若干分布式的数据库完成名字到IP地址的转换
>3. 运行在UDP之上端口号为53的应用服务
>4. 核心的Internet功能，但以应用层协议实现。在网络边缘处理复杂性
- DNS主要目的
>1. 实现主机名-IP地址的转换（name/Ip translate） ---主要目的
>2. 主机别名到规范名字的转换 host aliasing
>3. 负载均衡 loal distribution
###### DNS命名空间
- 命名空间：
>- 一个层面明明设备会有很多重名
>- DNS采用层次树状结构的命命名方法
>- Internet 根被划分为几百个顶级域名（top lever domains）
>- 每个子域下面可以分为若干子域（subdomains）
>- 树叶是主机
- 域名domain name
>- 从本域往上 ，直到树根
>- 中间使用“.”间隔不同级别
>- 域的域名：可以用于表示一个域
>- 主机的域名：一个域上的主机
- 域名管理
>- 一个域管理其下的子域
>- 创建一个新的域，必须征得它所属域的同意
- 域与物理网络无关
>- 域遵从组织界限，而不是物理网络
>- 一个域的主机可以不在一个网络，一个网络的主机不一定在一个域
>- 域的划分是逻辑的，而不是物理的
- 一个名字服务器的问题
>- 可靠性问题：单点故障
>- 扩展性问题：通信容量
>- 维护问题：远距离的集中式数据库
- 区域（zone）：
>- 区域的划分由区域管理者自己决定
>- 将DNS名字空间划分为互不相交的区域，每个区域都是树的一部分
>- 名字服务器：每个区域都有一个名字服务器，维护它所管辖区域的权威信息(authoritative record),名字服务器允许被放置在区域之外，以保障可靠性
- 根域名服务器，顶级域名服务器（TLD），权威DNS服务器

- 资源记录RR（resource records)
>- 作用：维护 域名-ip地址（其它）的映射关系
>- 位置：Name Server的分布式数据库中
- RR格式(name,value,type,ttl)
>- domain_name:域名
>- ttl:time to live :生存时间
>- Class 类别：对于Internet ，值为IN
>- value 值：可以是数字，域名或者ASCII串
>Type 类别：资源记录的类型

- DNS大致工作流程
>1. 应用调用 解析器（resolver）
>2. 解析器作为客户，向Name Server发出查询报文（封装在UDP中）
>3. Name Server反会响应报文（name/ip）

- 本地名字服务器（Local Name Server）
>- 并不严格属于层次结构
>- 每个ISP都有一个本地DNS服务器，也成为“默认名字服务器”
>- 当一个主机发起NDS查询时，查询被送到本地DNS服务器；起着代理作用，将查询转发到层次结构中
- 名字解析过程
>- 目标名字在Local Name Server中：查询的名字在区域内部；or  缓存（cashing）
>- 当于本地名字服务器不能解析名字时，联系根名字服务器。顺着根-TLD 一直找到权威名字服务器

- 迭代查询

- 递归查询

DNS协议：查询和响应报文的格式相同

- 提高性能：缓存
>- 一旦名字服务器学到了一个映射，就将该映射缓存起来
>- 根服务器通常在本地服务器缓存 ，使得根服务器不用经常被访问
>- 目的：提高效率
>- 可能存在的问题：如果情况变化，缓存结果和权威资源记录不一致。解决方案：TTL默认2天

- 总的来说 DNS比较健壮